// Generated by CoffeeScript 1.6.3
var MyApp, express,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

express = require('express');

module.exports = MyApp = (function() {
  function MyApp(graphDb) {
    var addID, addStrength, app, getvizjson, makeNodeJsonFromCypherQuery, port, shorten, trim;
    this.graphDb = graphDb;
    graphDb = this.graphDb;
    app = express.createServer(express.logger());
    app.configure(function() {
      app.set('views', __dirname + '/public');
      app.set('view options', {
        layout: false
      });
      app.use(express.methodOverride());
      app.use(express.bodyParser());
      app.use(app.router);
      return app.use(express["static"](__dirname + '/static'));
    });
    app.get('/', function(request, response) {
      return response.render('index.jade');
    });
    /*  Responds with a JSON formatted for D3JS viz of the entire Neo4j database*/

    app.get('/json', function(request, response) {
      var inputer;
      inputer = function(builder) {
        return response.json(builder);
      };
      return getvizjson(inputer, request, response);
    });
    /* Responds with a list of all the nodes*/

    app.get('/get_nodes', function(request, response) {
      var cypherQuery;
      console.log("get_nodes Query Requested");
      cypherQuery = "start n=node(*) return n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var nodeList;
        console.log("get_nodes Lookup Executed");
        nodeList = makeNodeJsonFromCypherQuery(noderes);
        return response.json(nodeList);
      });
    });
    /* Responds with a list of all the nodes 
        that have the shouldLoad attribute as true
    */

    app.get('/get_default_nodes', function(request, response) {
      var cypherQuery;
      console.log("get_default_nodes Query Requested");
      cypherQuery = "start n=node(*) where n.shouldLoad=\"true\" return n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var n, nodeList;
        console.log("get_default_nodes Lookup Executed");
        nodeList = (function() {
          var _i, _len, _ref, _results;
          _ref = noderes.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(addID(n[0].data, trim(n[0].self)[0]));
          }
          return _results;
        })();
        return response.json(nodeList);
      });
    });
    /* Creates a node using a Cypher query*/

    app.post('/create_node', function(request, response) {
      var cypherQuery, property, value, _ref;
      console.log("Node Creation Requested");
      cypherQuery = "create (n";
      if (JSON.stringify(request.body) !== '{}') {
        cypherQuery += " {";
        _ref = request.body;
        for (property in _ref) {
          value = _ref[property];
          cypherQuery += "" + property + ":'" + value + "', ";
        }
        cypherQuery = cypherQuery.substring(0, cypherQuery.length - 2) + "}";
      }
      cypherQuery += ") return n;";
      console.log("Executing " + cypherQuery);
      /*
      Problem: this does not allow properties to have spaces in them,
      e.g. "firstname: 'Will'" works but "first name: 'Will'" does not
      It seems like this problem could be avoided if Neo4js supported
      parameters in Cypher, but it does not, as far as I can see.
      */

      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var newNode, nodeID, nodeIDstart;
        console.log("query");
        nodeIDstart = noderes.data[0][0]["self"].lastIndexOf('/') + 1;
        nodeID = noderes.data[0][0]["self"].slice(nodeIDstart);
        console.log("Node Creation Done, ID = " + nodeID);
        newNode = noderes.data[0][0]["data"];
        newNode['_id'] = nodeID;
        console.log("newNode: ", newNode);
        return response.send(newNode);
      });
    });
    /* Creates a link using a Cypher query*/

    app.post('/create_link', function(request, response) {
      var cypherQuery, property, sourceNode, targetNode, value, _ref;
      console.log("Link Creation Requested");
      sourceNode = request.body.source;
      targetNode = request.body.target;
      console.log("sourceNode", sourceNode);
      console.log("targetNode", targetNode);
      cypherQuery = "start n=node(" + sourceNode['_id'] + "), m=node(" + targetNode['_id'] + ") create (n)-[r: link";
      if (request.body.properties !== void 0) {
        cypherQuery += " {";
        _ref = request.body.properties;
        for (property in _ref) {
          value = _ref[property];
          cypherQuery += "" + property + ":'" + value + "', ";
        }
        cypherQuery = cypherQuery.substring(0, cypherQuery.length - 2) + "}";
      }
      cypherQuery += "]->(m) return r;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(relres) {
        var newLink, newRelID, relIDstart;
        relIDstart = relres.data[0][0]["self"].lastIndexOf('/') + 1;
        newRelID = relres.data[0][0]["self"].slice(relIDstart);
        newLink = relres.data[0][0]["data"];
        newLink['_id'] = newRelID;
        newLink.source = sourceNode;
        newLink.start = sourceNode['_id'];
        newLink.target = targetNode;
        newLink.end = targetNode['_id'];
        newLink.strength = 1;
        console.log("here is the new link", newLink);
        return response.send(newLink);
      }, function(relres) {
        console.log(relres);
        return response.send("error");
      });
    });
    /*
    Gets a node by ID
    Request is of the form {nodeid: 9}
    */

    app.post('/get_node_by_id', function(request, response) {
      var cypherQuery;
      console.log("Node Data Requested");
      cypherQuery = "start n=node(" + request.body.nodeid + ") return n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        console.log("Node ID Lookup Executed");
        return response.json(noderes.data[0][0]["data"]);
      }, function(noderes) {
        console.log("Node not found");
        return response.send("error");
      });
    });
    /*
    get a link by id, request be of the form {id: 1}
    */

    app.post('/get_link_by_id', function(request, response) {
      var cypherQuery;
      console.log("Link Data Requested");
      cypherQuery = "start r=rel(" + request.body.id + ") return r;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(relres) {
        console.log("Link ID Lookup Executed");
        console.log(relres.data[0][0]);
        return response.json({
          from: trim(relres.data[0][0]["start"])[0],
          to: trim(relres.data[0][0]["end"])[0],
          type: relres.data[0][0]["type"],
          properties: relres.data[0][0]["data"]
        });
      }, function(relres) {
        console.log("Link not found");
        return response.send("error");
      });
    });
    /* Edits a node using a Cypher query*/

    app.post('/edit_node', function(request, response) {
      var cypherQuery, property, value, _i, _len, _ref, _ref1;
      console.log("Node Edit Requested");
      cypherQuery = "start n=node(" + request.body.nodeid + ") ";
      if (request.body.properties !== void 0) {
        cypherQuery += "set n.";
        _ref = request.body.properties;
        for (property in _ref) {
          value = _ref[property];
          cypherQuery += "" + property + "='" + value + "', n.";
        }
        cypherQuery = cypherQuery.substring(0, cypherQuery.length - 4);
      }
      if (request.body.remove !== void 0) {
        cypherQuery += " remove n.";
        _ref1 = request.body.remove;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          property = _ref1[_i];
          cypherQuery += "" + property + ", n.";
        }
        cypherQuery = cypherQuery.substring(0, cypherQuery.length - 4);
      }
      cypherQuery += " return n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var nodeID, nodeIDstart, savedNode;
        nodeIDstart = noderes.data[0][0]["self"].lastIndexOf('/') + 1;
        nodeID = noderes.data[0][0]["self"].slice(nodeIDstart);
        console.log("Node Edit Done, ID = " + nodeID);
        savedNode = noderes.data[0][0]["data"];
        savedNode['_id'] = nodeID;
        console.log("savedNode: ", savedNode);
        return response.json(savedNode);
      }, function(noderes) {
        console.log("Node Edit Failed");
        return response.send("error");
      });
    });
    /* Edits a link using a Cypher query*/

    app.post('/edit_link', function(request, response) {
      var cypherQuery, property, value, _i, _len, _ref, _ref1;
      console.log("Link Edit Requested");
      cypherQuery = "start r=rel(" + request.body.id + ") ";
      if (request.body.properties !== void 0) {
        cypherQuery += "set r.";
        _ref = request.body.properties;
        for (property in _ref) {
          value = _ref[property];
          cypherQuery += "" + property + "='" + value + "', r.";
        }
        cypherQuery = cypherQuery.substring(0, cypherQuery.length - 4);
      }
      if (request.body.remove !== void 0) {
        cypherQuery += " remove r.";
        _ref1 = request.body.remove;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          property = _ref1[_i];
          cypherQuery += "" + property + ", r.";
        }
        cypherQuery = cypherQuery.substring(0, cypherQuery.length - 4);
      }
      cypherQuery += " return r;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var nodeID, nodeIDstart;
        nodeIDstart = noderes.data[0][0]["self"].lastIndexOf('/') + 1;
        nodeID = noderes.data[0][0]["self"].slice(nodeIDstart);
        console.log("Link Edit Done, ID = " + nodeID);
        return response.json(noderes.data[0][0]["data"]);
      }, function(noderes) {
        console.log("Link Edit Failed");
        return response.send("error");
      });
    });
    /*
    Deletes a node
    */

    app.post('/delete_node', function(request, response) {
      var cypherQuery;
      console.log("Node Deletion Requested");
      cypherQuery = "start n=node(" + request.body['_id'] + ") delete n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        console.log("Node Deleted");
        return response.send("success");
      }, function(noderes) {
        console.log("Could Not Delete Node");
        return response.send("error");
      });
    });
    /*
    Deletes a node AND ALL LINKS TO IT
    */

    app.post('/delete_node_full', function(request, response) {
      var cypherQuery;
      console.log("Node Deletion Requested");
      cypherQuery = "start n=node(" + request.body['_id'] + ") match (n)-[r]-(m) delete r";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        console.log("Links Deleted");
        cypherQuery = "start n=node(" + request.body['_id'] + ") delete n;";
        console.log("Executing " + cypherQuery);
        return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
          console.log("Links and Node Deleted");
          return response.send("success");
        });
      });
    });
    /*
    Deletes a link
    */

    app.post('/delete_link', function(request, response) {
      var cypherQuery;
      console.log("Link Deletion Requested");
      cypherQuery = "start r=rel(" + request.body['_id'] + ") delete r;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        console.log("Link Deleted");
        return response.send("success");
      }, function(noderes) {
        console.log("Could Not Delete Link");
        return response.send("error");
      });
    });
    app.get('/node_names', function(request, response) {
      return graphDb.cypher.execute("start n=node(*) return n;").then(function(noderes) {
        var n, nodesNamesAndIds;
        console.log("Query Executed");
        nodesNamesAndIds = (function() {
          var _i, _len, _ref, _results;
          _ref = noderes.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push({
              name: n[0]['data']['name'],
              _id: trim(n[0]["self"])[0]
            });
          }
          return _results;
        })();
        return response.json(nodesNamesAndIds);
      });
    });
    app.get('/get_all_node_keys', function(request, response) {
      return graphDb.cypher.execute("start n=node(*) return n;").then(function(noderes) {
        var key, keys, n, nodeData, value, _i, _len;
        console.log("Get All Node Keys: Query Executed");
        nodeData = (function() {
          var _i, _len, _ref, _results;
          _ref = noderes.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(n[0].data);
          }
          return _results;
        })();
        keys = [];
        for (_i = 0, _len = nodeData.length; _i < _len; _i++) {
          n = nodeData[_i];
          for (key in n) {
            value = n[key];
            if (!(__indexOf.call(keys, key) >= 0)) {
              keys.push(key);
            }
          }
        }
        return response.json(keys.sort());
      });
    });
    app.post('/get_all_key_values', function(request, response) {
      var cypherQuery;
      cypherQuery = "start n=node(*) where has(n." + request.body.property + ") return n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var n, nodeData, values, _i, _len, _ref;
        console.log("Get All Key values: Query Executed");
        nodeData = (function() {
          var _i, _len, _ref, _results;
          _ref = noderes.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(n[0].data);
          }
          return _results;
        })();
        values = ['(any)'];
        for (_i = 0, _len = nodeData.length; _i < _len; _i++) {
          n = nodeData[_i];
          if (!(_ref = shorten(n[request.body.property]), __indexOf.call(values, _ref) >= 0)) {
            values.push(shorten(n[request.body.property]));
          }
        }
        return response.json(values.sort());
      });
    });
    app.post('/search_nodes', function(request, response) {
      var cypherQuery, property, value, _ref;
      console.log("Searching nodes");
      cypherQuery = "start n=node(*) where ";
      if (JSON.stringify(request.body) !== '{}') {
        _ref = request.body;
        for (property in _ref) {
          value = _ref[property];
          if (value === '(any)') {
            cypherQuery += "has(n." + property + ") and ";
          } else if (value.substr(-3) === '...') {
            cypherQuery += "n." + property + " =~ '" + (value.slice(0, -2)) + "*' and ";
          } else {
            cypherQuery += "n." + property + " = '" + value + "' and ";
          }
        }
        cypherQuery = cypherQuery.substring(0, cypherQuery.length - 4);
      }
      cypherQuery += "return n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var n, nodeList;
        nodeList = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = noderes.data;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            n = _ref1[_i];
            _results.push(addID(n[0].data, trim(n[0].self)[0]));
          }
          return _results;
        })();
        return response.json(nodeList);
      });
    });
    app.post('/get_links', function(request, response) {
      var cypherQuery, k, node, nodeIndexes, nodes;
      console.log("GET LINKS REQUESTED");
      node = request.body.node;
      nodes = request.body.nodes;
      if (!(nodes != null)) {
        response.send("error");
      }
      nodeIndexes = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          k = nodes[_i];
          _results.push(k["_id"]);
        }
        return _results;
      })();
      cypherQuery = "START n=node(" + node["_id"] + "), m=node(" + nodeIndexes + ") MATCH p=(n)-[]-(m) RETURN relationships(p);";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(relres) {
        var allSpokes, getLink, link, n, relList;
        console.log("Get Links executed");
        allSpokes = (function() {
          var _i, _len, _ref, _results;
          _ref = relres.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            link = _ref[_i];
            _results.push(addStrength(link[0][0].data, trim(link[0][0].start)[0], trim(link[0][0].end)[0], trim(link[0][0].self)[0], link[0][0].type));
          }
          return _results;
        })();
        getLink = function(nID) {
          var spoke, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = allSpokes.length; _i < _len; _i++) {
            spoke = allSpokes[_i];
            if (spoke.start === nID || spoke.end === nID) {
              _results.push(spoke);
            }
          }
          return _results;
        };
        relList = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = nodeIndexes.length; _i < _len; _i++) {
            n = nodeIndexes[_i];
            _results.push((getLink(n)[0] != null) ? getLink(n)[0] : {
              strength: 0
            });
          }
          return _results;
        })();
        return response.json(relList);
      }, function(relres) {
        console.log("Node not found");
        return response.send("error");
      });
    });
    app.get('/node_index_search_prefetch', function(request, response) {
      var cypherQuery;
      console.log("get_nodes Query Requested");
      cypherQuery = "start n=node(*) return n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var node, nodeList, tokens, typeaheadNode, typeaheadNodeList, _i, _len;
        console.log("get_nodes Lookup Executed");
        nodeList = makeNodeJsonFromCypherQuery(noderes);
        typeaheadNodeList = [];
        for (_i = 0, _len = nodeList.length; _i < _len; _i++) {
          node = nodeList[_i];
          typeaheadNode = {};
          typeaheadNode['name'] = node['name'];
          tokens = [];
          if (typeaheadNode['name'] != null) {
            typeaheadNode['tokens'] = typeaheadNode['name'].split(" ");
            typeaheadNodeList.push(typeaheadNode);
          }
        }
        return response.json(typeaheadNodeList);
      });
    });
    app.post('/get_linked_nodes', function(request, response) {
      var cypherQuery, n, nodeIndexes, nodes;
      console.log("GET LINKED NODES REQUESTED");
      nodes = request.body.nodes;
      console.log("NODES: ", nodes);
      nodeIndexes = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          n = nodes[_i];
          if (n["_id"] !== void 0) {
            _results.push(n["_id"]);
          }
        }
        return _results;
      })();
      cypherQuery = "START n=node(" + nodeIndexes + ") MATCH p=(n)-[]-(m) RETURN m;";
      console.log(cypherQuery);
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(nodeRes) {
        var node, nodeList;
        console.log("Get Linked Nodes executed");
        nodeList = (function() {
          var _i, _len, _ref, _results;
          _ref = nodeRes.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            _results.push(addID(node[0].data, trim(node[0].self)));
          }
          return _results;
        })();
        return response.json(nodeList);
      }, function(nodeRes) {
        console.log("Node not found");
        return response.send("error");
      });
    });
    app.post('/node_index_search', function(request, response) {
      var condition, cypherQuery, key, query, theKeys, _i, _len;
      theKeys = request.body.checkKeys;
      query = request.body.query;
      condition = "where ";
      for (_i = 0, _len = theKeys.length; _i < _len; _i++) {
        key = theKeys[_i];
        condition += "n." + key + "=~'(?i).*" + query + ".*' OR ";
      }
      condition += "False";
      cypherQuery = "start n=node(*) " + condition + " return n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var keyscondition, matchedKeys, n, nodeData, pattern, regexpression, _j, _len1;
        console.log("Node Index Search: Query Executed");
        nodeData = (function() {
          var _j, _len1, _ref, _results;
          _ref = noderes.data;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            n = _ref[_j];
            _results.push(addID(n[0].data, trim(n[0].self)[0]));
          }
          return _results;
        })();
        regexpression = ".*" + query + ".*";
        pattern = new RegExp(regexpression, "i");
        matchedKeys = [];
        matchedKeys = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = theKeys.length; _j < _len1; _j++) {
            key = theKeys[_j];
            if (key.match(pattern) != null) {
              _results.push(key);
            }
          }
          return _results;
        })();
        if (matchedKeys.length > 0) {
          keyscondition = "where ";
          for (_j = 0, _len1 = matchedKeys.length; _j < _len1; _j++) {
            key = matchedKeys[_j];
            keyscondition += "has(n." + key + ") OR ";
          }
          keyscondition += "False";
          cypherQuery = "start n=node(*) " + keyscondition + " return n;";
          console.log("Executing " + cypherQuery);
          return graphDb.cypher.execute(cypherQuery).then(function(matchedKeys) {
            var nodeDataKeys;
            nodeDataKeys = (function() {
              var _k, _len2, _ref, _results;
              _ref = matchedKeys.data;
              _results = [];
              for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
                n = _ref[_k];
                _results.push(addID(n[0].data, trim(n[0].self)[0]));
              }
              return _results;
            })();
            return response.json(nodeData.concat(nodeDataKeys));
          });
        } else {
          return response.json(nodeData);
        }
      });
    });
    app.get('/node_index_search_prefetch1', function(request, response) {
      var cypherQuery;
      console.log("get_nodes Query Requested");
      cypherQuery = "start n=node(*) return n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var n, node, nodeList, tokens, typeaheadNode, typeaheadNodeList, _i, _len;
        console.log("node index search prefeterh Executed");
        nodeList = (function() {
          var _i, _len, _ref, _results;
          _ref = noderes.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(addID(n[0].data, trim(n[0].self)[0]));
          }
          return _results;
        })();
        typeaheadNodeList = [];
        for (_i = 0, _len = nodeList.length; _i < _len; _i++) {
          node = nodeList[_i];
          typeaheadNode = {};
          typeaheadNode['name'] = node.name;
          tokens = node.name.split();
          typeaheadNode['tokens'] = tokens;
          typeaheadNodeList.append(typeaheadNode);
        }
        return response.json(typeaheadNodeList);
      });
    });
    app.get('/node_index_search_prefetch', function(request, response) {
      var cypherQuery;
      console.log("get_nodes Query Requested");
      cypherQuery = "start n=node(*) return n;";
      console.log("Executing " + cypherQuery);
      return graphDb.cypher.execute(cypherQuery).then(function(noderes) {
        var node, nodeList, tokens, typeaheadNode, typeaheadNodeList, _i, _len;
        console.log("get_nodes Lookup Executed");
        nodeList = makeNodeJsonFromCypherQuery(noderes);
        typeaheadNodeList = [];
        for (_i = 0, _len = nodeList.length; _i < _len; _i++) {
          node = nodeList[_i];
          typeaheadNode = {};
          typeaheadNode['name'] = node['name'];
          tokens = [];
          if (typeaheadNode['name'] != null) {
            typeaheadNode['tokens'] = typeaheadNode['name'].split(" ");
            typeaheadNodeList.push(typeaheadNode);
          }
        }
        return response.json(typeaheadNodeList);
      });
    });
    port = process.env.PORT || 3000;
    app.listen(port, function() {
      return console.log("Listening on " + port);
    });
    addStrength = function(dict, start, end, id, type) {
      dict['strength'] = 1;
      dict['start'] = start;
      dict['end'] = end;
      dict['_id'] = id + "";
      dict['_type'] = type;
      return dict;
    };
    trim = function(string) {
      return string.match(/[0-9]*$/);
    };
    shorten = function(string) {
      var maxLength;
      maxLength = 30;
      if (string.length > maxLength) {
        return string.substring(0, maxLength - 3) + "...";
      } else {
        return string;
      }
    };
    addID = function(dict, id) {
      dict['_id'] = id + "";
      return dict;
    };
    /* makes queries of database to build a JSON formatted for D3JS viz of the entire Neo4j database
      that is stored in the displaydata variable.
    */

    getvizjson = function(callback, request, response) {
      console.log("making getvizjson");
      return graphDb.cypher.execute("start n=node(*) return n;").then(function(noderes) {
        var nodedata, nodeids, ntmp, num;
        console.log("Query Executed");
        nodeids = (function() {
          var _i, _len, _ref, _results;
          _ref = noderes.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            num = _ref[_i];
            _results.push(trim(num[0]["self"]));
          }
          return _results;
        })();
        /* Generate reindexing array*/

        var nodeconvert = {};
          for (i = 0; i < nodeids.length; i++) {
            nodeconvert[nodeids[i]+'']=i;            
          };
        nodedata = (function() {
          var _i, _len, _ref, _results;
          _ref = noderes.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            ntmp = _ref[_i];
            _results.push(ntmp[0]["data"]);
          }
          return _results;
        })();
        for (i=0; i < nodeids.length; i++) {
             nodedata[i]["_id"] = nodeids[i]+'';
          };
        return graphDb.cypher.execute("start n=rel(*) return n;").then(function(arrres) {
          var arrdata, displaydata;
          console.log("Query Executed");
          arrdata = (function() {
            var _i, _len, _ref, _results;
            _ref = arrres.data;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              ntmp = _ref[_i];
              _results.push({
                source: nodeconvert[trim(ntmp[0]["start"])],
                target: nodeconvert[trim(ntmp[0]["end"])]
              });
            }
            return _results;
          })();
          displaydata = [
            {
              nodes: nodedata,
              links: arrdata
            }
          ][0];
          return callback(displaydata);
        });
      });
    };
    makeNodeJsonFromCypherQuery = function(noderes) {
      var n, nodeList;
      nodeList = (function() {
        var _i, _len, _ref, _results;
        _ref = noderes.data;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          _results.push(addID(n[0].data, trim(n[0].self)[0]));
        }
        return _results;
      })();
      return nodeList;
    };
  }

  return MyApp;

})();
